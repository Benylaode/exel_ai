<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spreadsheet Alam</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter for a clean sans-serif look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Apply Inter as the main font */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for overflow elements */
        .custom-scrollbar::-webkit-scrollbar {
            height: 8px;
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #e0f2f1; /* Light green for track */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #4caf50; /* Green for thumb */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #388e3c; /* Darker green on hover */
        }
        /* Table specific styles for better appearance */
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            overflow: hidden; /* Ensures rounded corners apply to table content */
        }
        th, td {
            border: 1px solid #e0e0e0;
            padding: 8px 10px; /* Slightly more padding than before */
            text-align: left;
            font-size: 0.9em;
        }
        th {
            background: #e9ecef; /* Lighter grey for headers */
            font-weight: bold;
            color: #495057;
            position: sticky; /* Sticky header */
            top: 0;
            z-index: 1; /* Ensure header stays above scrolling content */
        }
        tbody tr:nth-child(even) {
            background-color: #f8f9fa; /* Zebra striping for rows */
        }
        tbody tr:hover {
            background-color: #e2f0ff; /* Highlight on hover */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- React CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel Standalone for JSX transformation in browser (for development only) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- XLSX library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <script type="text/babel">
        const App = () => {
            const [workbook, setWorkbook] = React.useState(null);
            const [sheetNames, setSheetNames] = React.useState([]);
            const [activeSheetName, setActiveSheetName] = React.useState('');
            // matrixData will now be an array of row objects, directly from AI parsing
            const [matrixData, setMatrixData] = React.useState([]); 
            const [headers, setHeaders] = React.useState([]); // Headers extracted by AI
            const [message, setMessage] = React.useState('');
            const fileInputRef = React.useRef(null);

            // State for AI generation feature
            const [showAIPromptModal, setShowAIPromptModal] = React.useState(false);
            const [aiPrompt, setAiPrompt] = React.useState('');
            const [isGeneratingAI, setIsGeneratingAI] = React.useState(false); // Used for both content gen and table parsing

            // State for voice input feature
            const [showVoiceInputModal, setShowVoiceInputModal] = React.useState(false);
            const [voiceStatus, setVoiceStatus] = React.useState('Siap');
            const [recognition, setRecognition] = React.useState(null);

            // State to store inferred column types (based on AI-parsed data)
            const [columnTypes, setColumnTypes] = React.useState({}); 

            // The main identifier for a row will be the value in the first column (headers[0])
            // This is used for AI commands and internal mapping.
            const getRowIdentifier = (rowObject, index) => {
                if (headers.length > 0 && rowObject[headers[0]] !== undefined && String(rowObject[headers[0]]).trim() !== '') {
                    return String(rowObject[headers[0]]).trim();
                }
                return `Baris ${index + 1}`; // Fallback if first column is empty
            };

            // Helper to infer column types based on the AI-parsed data
            const inferColumnTypes = (currentHeaders, jsonRows) => {
                if (!jsonRows || jsonRows.length < 1 || !currentHeaders || currentHeaders.length === 0) {
                    setColumnTypes({});
                    return;
                }

                const newColumnTypes = {};

                currentHeaders.forEach((header, colIndex) => {
                    let numericCount = 0;
                    let binaryCount = 0;
                    let totalCells = 0;

                    jsonRows.forEach(rowObject => {
                        const cellValue = rowObject[header]; // Access by header name
                        if (cellValue !== null && cellValue !== undefined && String(cellValue).trim() !== '') {
                            totalCells++;
                            const numericValue = parseFloat(cellValue);
                            if (!isNaN(numericValue)) {
                                numericCount++;
                            }
                            const lowerCaseValue = String(cellValue).toLowerCase();
                            if (['ya', 'tidak', 'true', 'false', '1', '0'].includes(lowerCaseValue)) {
                                binaryCount++;
                            }
                        }
                    });

                    if (totalCells > 0) {
                        if (numericCount / totalCells > 0.8) { // If more than 80% are numbers
                            newColumnTypes[colIndex] = 'number';
                        } else if (binaryCount / totalCells > 0.8) { // If more than 80% are binary
                            newColumnTypes[colIndex] = 'binary';
                        } else {
                            newColumnTypes[colIndex] = 'text';
                        }
                    } else {
                        newColumnTypes[colIndex] = 'text'; // Default to text if no data
                    }
                });
                setColumnTypes(newColumnTypes);
            };

            // Function to process Excel data using Gemini AI
            const processExcelDataWithAI = async (wb, sheetName) => {
                setIsGeneratingAI(true); // Activate loading state for AI processing
                setMessage(`Memproses sheet '${sheetName}' dengan AI...`);

                try {
                    const ws = wb.Sheets[sheetName];
                    
                    // Step 1: Get raw data as array of arrays (AoA) to handle complex headers
                    // Use { header: 1, raw: true } to get all cells as they are, without auto-header detection
                    const rawAoAData = XLSX.utils.sheet_to_json(ws, { header: 1, raw: true }); 

                    if (rawAoAData.length === 0) {
                        setHeaders([]);
                        setMatrixData([]);
                        setColumnTypes({});
                        setMessage(`Sheet '${sheetName}' kosong atau tidak memiliki data yang dapat diproses.`);
                        setIsGeneratingAI(false);
                        return;
                    }

                    // Step 2: Convert raw AoA data to CSV string for AI input.
                    // This is robust for merged cells as XLSX.utils.sheet_to_csv repeats values.
                    const csvString = XLSX.utils.sheet_to_csv(ws, { FS: ',', RS: '\n', blankrows: false });

                    if (!csvString.trim()) {
                        setHeaders([]);
                        setMatrixData([]);
                        setColumnTypes({});
                        setMessage(`Sheet '${sheetName}' kosong atau tidak memiliki data yang dapat diproses.`);
                        setIsGeneratingAI(false);
                        return;
                    }

                    // Prompt for Gemini to parse the table
                    const geminiPrompt = `Ekstrak data tabel dari teks berikut.
                    Identifikasi header dari baris pertama yang tidak kosong. Jika ada header yang digabungkan atau multi-baris, coba ratakan menjadi satu baris header yang bermakna.
                    Perlakukan setiap baris selanjutnya yang tidak kosong sebagai entri data.
                    Abaikan baris apa pun yang terlihat seperti baris ringkasan atau total (misalnya, mengandung 'Total', 'Jumlah', 'Sum', 'Rata-rata', 'Average', 'Max', 'Min' pada kolom pertama atau kunci).
                    Berikan output sebagai objek JSON dengan dua kunci: \`headers\` (array string dari nama header) dan \`rows\` (array objek, di mana setiap objek merepresentasikan baris data dengan kunci adalah header dan nilai adalah konten sel).
                    Pastikan semua nilai dipertahankan sebagai tipe aslinya jika memungkinkan (angka, string, boolean).
                    
                    Data tabel (format CSV):
                    \`\`\`csv
                    ${csvString}
                    \`\`\`
                    
                    Output JSON:`;

                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: geminiPrompt }] });
                    const payload = {
                        contents: chatHistory,
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    "headers": {
                                        type: "ARRAY",
                                        items: { type: "STRING" }
                                    },
                                    "rows": {
                                        type: "ARRAY",
                                        items: { type: "OBJECT" } // Object schema is flexible for any table structure
                                    }
                                },
                                required: ["headers", "rows"]
                            }
                        }
                    };
                    const apiKey = ""; // API key is provided by the environment
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        let jsonText = result.candidates[0].content.parts[0].text;
                        
                        // Log the raw JSON text for debugging
                        console.log("[AI Raw JSON Output]:", jsonText);

                        // Robust parsing: Try to find the JSON object within the text
                        // This regex looks for a string starting with '{' and ending with '}'
                        // and tries to capture everything in between.
                        const jsonRegex = /{[\s\S]*}/;
                        const jsonMatch = jsonText.match(jsonRegex);
                        
                        if (jsonMatch && jsonMatch[0]) {
                            jsonText = jsonMatch[0]; // Use the matched JSON string
                        } else {
                            // Fallback if regex doesn't find a clean JSON block
                            // This might happen if AI returns only partial JSON or non-JSON text
                            setMessage('AI mengembalikan respons yang tidak dapat diuraikan sebagai JSON. Coba lagi atau periksa format file.');
                            console.error('JSON object boundaries not found. Raw AI text:', jsonText);
                            setHeaders([]);
                            setMatrixData([]);
                            setColumnTypes({});
                            setIsGeneratingAI(false);
                            return;
                        }

                        let parsedData;
                        try {
                            parsedData = JSON.parse(jsonText);
                        } catch (parseError) {
                            setMessage('AI mengembalikan respons yang tidak dapat diuraikan sebagai JSON. Coba lagi atau periksa format file.');
                            console.error('JSON parsing error:', parseError);
                            console.error('Text attempted to parse:', jsonText);
                            setHeaders([]);
                            setMatrixData([]);
                            setColumnTypes({});
                            setIsGeneratingAI(false);
                            return;
                        }

                        if (parsedData.headers && Array.isArray(parsedData.headers) &&
                            parsedData.rows && Array.isArray(parsedData.rows)) {
                            setHeaders(parsedData.headers);
                            setMatrixData(parsedData.rows);
                            inferColumnTypes(parsedData.headers, parsedData.rows); // Infer types based on AI-parsed data
                            setMessage(`Sheet '${sheetName}' berhasil diproses oleh AI.`);
                        } else {
                            setMessage('AI gagal menginterpretasikan struktur tabel. Coba lagi atau periksa format file.');
                            console.error('Unexpected AI parsed data structure:', parsedData);
                            setHeaders([]);
                            setMatrixData([]);
                            setColumnTypes({});
                        }
                    } else {
                        setMessage('Gagal mendapatkan respons dari AI. Coba lagi.');
                        console.error('Unexpected AI response structure:', result);
                        setHeaders([]);
                        setMatrixData([]);
                        setColumnTypes({});
                    }
                } catch (error) {
                    console.error('Error processing Excel data with AI:', error);
                    setMessage(`Terjadi kesalahan saat memproses file dengan AI: ${error.message}.`);
                    setHeaders([]);
                    setMatrixData([]);
                    setColumnTypes({});
                } finally {
                    setIsGeneratingAI(false); // Deactivate loading state
                }
            };

            // Effect to load data when workbook or active sheet changes
            React.useEffect(() => {
                if (workbook && activeSheetName) {
                    if (typeof XLSX !== 'undefined' && XLSX.utils) {
                        processExcelDataWithAI(workbook, activeSheetName); // Use AI for processing
                    } else {
                        setMessage('Pustaka XLSX belum dimuat. Harap segarkan halaman.');
                    }
                }
            }, [workbook, activeSheetName]);

            // Initialize SpeechRecognition API
            React.useEffect(() => {
                if ('webkitSpeechRecognition' in window) {
                    const SpeechRecognition = window.webkitSpeechRecognition;
                    const recognitionInstance = new SpeechRecognition();
                    recognitionInstance.continuous = false; // Listen for a single utterance
                    recognitionInstance.interimResults = false; // Only return final results
                    recognitionInstance.lang = 'id-ID'; // Set language to Indonesian

                    recognitionInstance.onstart = () => {
                        setVoiceStatus('Mendengarkan...');
                    };

                    recognitionInstance.onresult = (event) => {
                        const transcript = event.results[0][0].transcript;
                        setVoiceStatus(`Terdengar: "${transcript}"`);
                        processVoiceCommand(transcript);
                    };

                    recognitionInstance.onerror = (event) => {
                        console.error('Speech recognition error:', event.error);
                        setVoiceStatus(`Kesalahan: ${event.error}. Coba lagi.`);
                        setIsGeneratingAI(false); // Reset loading state
                    };

                    recognitionInstance.onend = () => {
                        if (voiceStatus.startsWith('Mendengarkan')) { // If it ended without result
                            setVoiceStatus('Tidak ada suara terdeteksi.');
                            setIsGeneratingAI(false); // Reset loading state
                        }
                    };
                    setRecognition(recognitionInstance);
                } else {
                    setVoiceStatus('Browser Anda tidak mendukung Web Speech API.');
                }
            }, []); // Run once on component mount

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (!file) {
                    setMessage('Tidak ada file yang dipilih.');
                    return;
                }

                if (typeof XLSX === 'undefined' || !XLSX.read) {
                    setMessage('Pustaka XLSX belum dimuat. Harap segarkan halaman atau coba lagi.');
                    return;
                }

                setMessage('Mengunggah dan memproses file...');
                const reader = new FileReader();

                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const wb = XLSX.read(data, { type: "array", cellDates: true });
                        setWorkbook(wb);
                        setSheetNames(wb.SheetNames);
                        if (wb.SheetNames.length > 0) {
                            setActiveSheetName(wb.SheetNames[0]);
                            setMessage(`File "${file.name}" berhasil diunggah. Memuat sheet pertama.`);
                            // useEffect will trigger processExcelDataWithAI
                        } else {
                            setMessage('File Excel tidak memiliki sheet.');
                            setMatrixData([]);
                            setHeaders([]);
                            setColumnTypes({});
                        }
                    } catch (error) {
                        console.error('Error reading Excel file:', error);
                        setMessage('Gagal membaca file Excel. Pastikan formatnya benar.');
                        setWorkbook(null);
                        setSheetNames([]);
                        setActiveSheetName('');
                        setMatrixData([]);
                        setHeaders([]);
                        setColumnTypes({});
                    }
                };

                reader.onerror = () => {
                    setMessage('Gagal membaca file.');
                    setWorkbook(null);
                    setSheetNames([]);
                    setActiveSheetName('');
                    setMatrixData([]);
                    setHeaders([]);
                    setColumnTypes({});
                };

                reader.readAsArrayBuffer(file);
            };

            const handleSheetChange = (sheetName) => {
                setActiveSheetName(sheetName);
                setMessage(`Beralih ke sheet: ${sheetName}`);
                // useEffect will trigger processExcelDataWithAI
            };

            // Update cell in matrixData (array of objects) and then sync back to workbook
            const updateCell = (rowIndex, columnHeader, value) => {
                const newMatrixData = [...matrixData];
                // Find the actual row object to update
                const targetRowObject = newMatrixData[rowIndex]; 

                if (targetRowObject) {
                    targetRowObject[columnHeader] = value;
                    setMatrixData(newMatrixData);

                    // Sync back to workbook
                    if (workbook && activeSheetName && typeof XLSX !== 'undefined' && XLSX.utils) {
                        const newSheetDataAoA = convertMatrixDataToSheetData(newMatrixData, headers);
                        const ws = XLSX.utils.aoa_to_sheet(newSheetDataAoA);
                        workbook.Sheets[activeSheetName] = ws;
                    }
                } else {
                    console.error("Row not found for update:", rowIndex, columnHeader);
                }
            };

            const handleCellChange = (rowIndex, columnHeader, value) => {
                updateCell(rowIndex, columnHeader, value);
            };

            const handleBinaryToggle = (rowIndex, columnHeader) => {
                const currentValue = String(matrixData[rowIndex][columnHeader]).toLowerCase();
                const newValue = (currentValue === 'ya' || currentValue === 'true' || currentValue === '1') ? 'Tidak' : 'Ya';
                updateCell(rowIndex, columnHeader, newValue);
            };

            const handleAddRow = (content = null) => {
                const newMatrixData = [...matrixData];
                const newRowObject = {};
                
                // Initialize all headers with empty strings
                headers.forEach(header => {
                    newRowObject[header] = '';
                });

                // If content is provided, put it in the first column
                if (content && headers.length > 0) {
                    newRowObject[headers[0]] = content;
                } else if (content) {
                    newRowObject['Kolom 1'] = content; // Fallback if no headers at all
                }

                newMatrixData.push(newRowObject);
                setMatrixData(newMatrixData);

                // Sync back to workbook
                if (workbook && activeSheetName && typeof XLSX !== 'undefined' && XLSX.utils) {
                    const newSheetDataAoA = convertMatrixDataToSheetData(newMatrixData, headers);
                    const ws = XLSX.utils.aoa_to_sheet(newSheetDataAoA);
                    workbook.Sheets[activeSheetName] = ws;
                    setMessage(content ? 'Baris baru dengan konten AI ditambahkan.' : 'Baris baru ditambahkan.');
                }
            };

            const handleCalculateTotals = () => {
                if (!matrixData || matrixData.length === 0 || headers.length === 0) {
                    setMessage('Tidak ada data untuk dihitung total.');
                    return;
                }

                const totalsRowObject = {};
                headers.forEach((header) => {
                    if (header === headers[0]) { // First column for "Total" label
                        totalsRowObject[header] = 'Total';
                        return;
                    }

                    let sum = 0;
                    let isNumericColumn = true;
                    matrixData.forEach(rowObject => {
                        const cellValue = rowObject[header];
                        const numericValue = parseFloat(cellValue);
                        if (!isNaN(numericValue) && cellValue !== '' && cellValue !== null && cellValue !== undefined) {
                            sum += numericValue;
                        } else if (cellValue !== '' && cellValue !== null && cellValue !== undefined) {
                            isNumericColumn = false;
                        }
                    });

                    if (isNumericColumn) {
                        totalsRowObject[header] = sum;
                    } else {
                        totals[header] = ''; // Non-numeric columns don't get a sum
                    }
                });

                const newMatrixData = [...matrixData];
                
                // Find and replace existing "Total" row, or add a new one
                let totalRowIndex = -1;
                for (let i = 0; i < newMatrixData.length; i++) {
                    if (String(newMatrixData[i][headers[0]] || '').toLowerCase() === 'total') {
                        totalRowIndex = i;
                        break;
                    }
                }

                if (totalRowIndex !== -1) {
                    newMatrixData[totalRowIndex] = totalsRowObject;
                } else {
                    newMatrixData.push(totalsRowObject);
                }
                
                setMatrixData(newMatrixData);

                // Sync back to workbook
                if (workbook && activeSheetName && typeof XLSX !== 'undefined' && XLSX.utils) {
                    const newSheetDataAoA = convertMatrixDataToSheetData(newMatrixData, headers);
                    const ws = XLSX.utils.aoa_to_sheet(newSheetDataAoA);
                    workbook.Sheets[activeSheetName] = ws;
                    setMessage('Total kolom dihitung dan ditambahkan.');
                }
            };

            const handleGenerateAIContent = async () => {
                if (!aiPrompt.trim()) {
                    setMessage('Mohon masukkan prompt untuk AI.');
                    return;
                }
                if (!workbook || !activeSheetName) {
                    setMessage('Harap unggah file Excel terlebih dahulu.');
                    return;
                }

                setIsGeneratingAI(true);
                setMessage('Menghasilkan konten AI...');

                try {
                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: aiPrompt }] });
                    const payload = { contents: chatHistory };
                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const text = result.candidates[0].content.parts[0].text;
                        handleAddRow(text); // Add AI generated content as a new row (primary key)
                        setMessage('Konten AI berhasil dihasilkan dan ditambahkan.');
                    } else {
                        setMessage('Gagal menghasilkan konten AI. Coba lagi.');
                        console.error('Unexpected AI response structure:', result);
                    }
                } catch (error) {
                    console.error('Error calling Gemini API:', error);
                    setMessage('Terjadi kesalahan saat menghubungi AI. Mohon coba lagi.');
                } finally {
                    setIsGeneratingAI(false);
                    setShowAIPromptModal(false);
                    setAiPrompt('');
                }
            };

            const startVoiceInput = () => {
                if (recognition) {
                    setVoiceStatus('Mendengarkan...');
                    setShowVoiceInputModal(true);
                    recognition.start();
                } else {
                    setVoiceStatus('Web Speech API tidak tersedia.');
                }
            };

            const processVoiceCommand = async (command) => {
                setVoiceStatus('Memproses perintah suara dengan AI...');
                setIsGeneratingAI(true); // Reuse loading state for AI processing

                // Prepare current row identifiers for the AI prompt
                const currentRowIdentifiers = matrixData.map((row, index) => getRowIdentifier(row, index));

                const geminiPrompt = `Parse this command to identify the target column's HEADER NAME (case-insensitive), the unique identifier for the row (which is the value from the first column of your spreadsheet, case-insensitive), and the new value to be set. Respond in JSON format.
                If the command is not clear, respond with an empty JSON object {}.
                
                Current spreadsheet HEADER NAMES: ${JSON.stringify(headers || [])}
                Current ROW IDENTIFIERS (values from the first column of each data row, example: "Amphibia", "Reptilia"): ${JSON.stringify(currentRowIdentifiers || [])}
                
                Examples:
                - "Untuk baris 'Amphibia' di kolom 'jum', atur nilai menjadi 10" -> { "column": "jum", "row_identifier_value": "Amphibia", "new_value": 10 }
                - "Untuk baris 'Reptilia' di kolom 'F', masukkan 0.75" -> { "column": "F", "row_identifier_value": "Reptilia", "new_value": 0.75 }
                
                Command to parse: "${command}"`;

                try {
                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: geminiPrompt }] });
                    const payload = {
                        contents: chatHistory,
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    "column": { "type": "STRING" },
                                    "row_identifier_value": { "type": "STRING" },
                                    "new_value": { "type": ["STRING", "NUMBER", "BOOLEAN"] }
                                },
                                required: ["column", "row_identifier_value", "new_value"]
                            }
                        }
                    };
                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        const parsedCommand = JSON.parse(jsonText);

                        const { column, row_identifier_value, new_value } = parsedCommand;

                        if (!column || !row_identifier_value || new_value === undefined) {
                            setMessage('Perintah suara tidak jelas atau tidak lengkap.');
                            setVoiceStatus('Perintah tidak dapat dipahami.');
                            return;
                        }

                        // Find the actual row index based on the row identifier
                        const targetRowIndex = matrixData.findIndex((row, index) => 
                            String(getRowIdentifier(row, index)).toLowerCase() === String(row_identifier_value).toLowerCase()
                        );

                        if (targetRowIndex === -1) {
                            setMessage(`Baris dengan pengenal '${row_identifier_value}' tidak ditemukan.`);
                            setVoiceStatus(`Baris tidak ditemukan.`);
                            return;
                        }

                        // Find the actual column header (case-insensitive match)
                        const actualColumnHeader = headers.find(header => String(header).toLowerCase() === String(column).toLowerCase());

                        if (!actualColumnHeader) {
                            setMessage(`Kolom '${column}' tidak ditemukan.`);
                            setVoiceStatus(`Kolom '${column}' tidak ditemukan.`);
                            return;
                        }

                        updateCell(targetRowIndex, actualColumnHeader, new_value);
                        setMessage(`Berhasil memperbarui kolom '${actualColumnHeader}' di baris '${row_identifier_value}' menjadi '${new_value}'.`);
                        setVoiceStatus('Berhasil diperbarui!');

                    } else {
                        setMessage('Gagal memproses perintah suara dengan AI. Coba lagi.');
                        setVoiceStatus('Gagal memproses perintah.');
                        console.error('Unexpected AI response structure:', result);
                    }
                } catch (error) {
                    console.error('Error processing voice command with Gemini API:', error);
                    setMessage('Terjadi kesalahan saat memproses perintah suara. Mohon coba lagi.');
                    setVoiceStatus('Kesalahan pemrosesan.');
                } finally {
                    setIsGeneratingAI(false); // Reset loading state
                    // setShowVoiceInputModal(false); // Keep modal open to show status
                }
            };


            const handleDownload = () => {
                if (!workbook) {
                    setMessage('Tidak ada file Excel untuk diunduh.');
                    return;
                }

                if (typeof XLSX === 'undefined' || !XLSX.utils || !XLSX.writeFile) {
                    setMessage('Pustaka XLSX belum dimuat. Harap segarkan halaman atau coba lagi.');
                    return;
                }

                try {
                    const wb = XLSX.utils.book_new();
                    sheetNames.forEach(sheetName => {
                        let ws;
                        // For the active sheet, convert current matrixData back to AoA
                        if (sheetName === activeSheetName) {
                            ws = XLSX.utils.aoa_to_sheet(convertMatrixDataToSheetData(matrixData, headers));
                        } else {
                            // For other sheets, use the original workbook sheet data
                            // This requires storing original AoA for all sheets or re-reading them,
                            // for simplicity, we'll just use the workbook's current state for non-active sheets.
                            ws = workbook.Sheets[sheetName];
                        }
                        XLSX.utils.book_append_sheet(wb, ws, sheetName);
                    });

                    XLSX.writeFile(wb, 'modified_spreadsheet.xlsx');
                    setMessage('File Excel berhasil diunduh.');
                } catch (error) {
                    console.error('Error downloading Excel file:', error);
                    setMessage('Gagal mengunduh file Excel.');
                }
            };

            return (
                <div className="min-h-screen flex flex-col font-sans bg-green-100 text-gray-800">
                    {/* Header Section - Simplified and Clean */}
                    <header className="bg-green-700 text-white p-4 shadow-lg">
                        <div className="container mx-auto flex justify-between items-center">
                            <h1 className="text-2xl font-semibold">Spreadsheet Alam</h1>
                            <div className="flex space-x-4">
                                {/* Search Icon */}
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="2" stroke="currentColor" className="w-6 h-6">
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z" />
                                </svg>
                                {/* Bag Icon */}
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="2" stroke="currentColor" className="w-6 h-6">
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 10.5V6a3.75 3.75 0 10-7.5 0v4.5m11.356-1.993l1.263 12c.07.665-.45 1.243-1.119 1.243H4.25a1.125 1.125 0 01-1.12-1.243l1.264-12A1.125 1.125 0 015.513 7.5h12.974c.576 0 1.059.435 1.119 1.007zM8.625 10.5a.375.375 0 11-.75 0 .375.375 0 01.75 0zm7.5 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" />
                                </svg>
                            </div>
                        </div>
                    </header>

                    {/* Main Content Area */}
                    <main className="flex-grow flex flex-col items-center p-4">
                        <div className="bg-white p-6 rounded-xl shadow-lg w-full max-w-6xl border border-gray-200">
                            <h2 className="text-2xl font-semibold text-center text-gray-800 mb-6">Editor Spreadsheet Interaktif</h2>

                            {/* Sheet Navigation / Filters */}
                            {sheetNames.length > 1 && (
                                <div className="mb-4 flex flex-wrap justify-center gap-2">
                                    {sheetNames.map((name) => (
                                        <button
                                            key={name}
                                            onClick={() => handleSheetChange(name)}
                                            className={`px-4 py-2 rounded-full text-sm font-medium transition duration-300 ease-in-out ${
                                                activeSheetName === name
                                                    ? 'bg-green-600 text-white shadow-md'
                                                    : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                            }`}
                                        >
                                            {name}
                                        </button>
                                    ))}
                                </div>
                            )}

                            {/* Main Action Buttons */}
                            <div className="mb-6 flex flex-col sm:flex-row items-center justify-center gap-3 flex-wrap">
                                <input
                                    type="file"
                                    accept=".xlsx, .xls"
                                    onChange={handleFileUpload}
                                    ref={fileInputRef}
                                    className="hidden"
                                />
                                <button
                                    onClick={() => fileInputRef.current.click()}
                                    className="px-5 py-2 bg-green-600 text-white font-semibold rounded-full shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition duration-300 ease-in-out"
                                >
                                    Unggah File Excel
                                </button>

                                {workbook && (
                                    <>
                                        <button
                                            onClick={() => handleAddRow()}
                                            className="px-5 py-2 bg-blue-500 text-white font-semibold rounded-full shadow-sm hover:bg-blue-600 transition duration-300 ease-in-out"
                                        >
                                            Tambah Baris
                                        </button>
                                        <button
                                            onClick={handleCalculateTotals}
                                            className="px-5 py-2 bg-purple-500 text-white font-semibold rounded-full shadow-sm hover:bg-purple-600 transition duration-300 ease-in-out"
                                        >
                                            Hitung Semua Total
                                        </button>
                                        <button
                                            onClick={() => setShowAIPromptModal(true)}
                                            className="px-5 py-2 bg-yellow-500 text-white font-semibold rounded-full shadow-sm hover:bg-yellow-600 transition duration-300 ease-in-out"
                                        >
                                            Hasilkan Konten AI
                                        </button>
                                        <button
                                            onClick={startVoiceInput}
                                            className="px-5 py-2 bg-indigo-500 text-white font-semibold rounded-full shadow-sm hover:bg-indigo-600 transition duration-300 ease-in-out"
                                        >
                                            Input Suara AI
                                        </button>
                                        <button
                                            onClick={handleDownload}
                                            className="px-5 py-2 bg-teal-500 text-white font-semibold rounded-full shadow-sm hover:bg-teal-600 transition duration-300 ease-in-out"
                                        >
                                            Unduh Excel
                                        </button>
                                    </>
                                )}
                            </div>

                            {message && (
                                <p className="text-center text-gray-600 mb-4">{message}</p>
                            )}

                            {/* Data Table Display */}
                            {isGeneratingAI ? (
                                <div className="flex justify-center items-center h-48">
                                    <svg className="animate-spin h-10 w-10 text-green-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    <p className="ml-3 text-lg text-gray-700">Memproses data dengan AI...</p>
                                </div>
                            ) : matrixData.length > 0 && headers.length > 0 ? (
                                <div className="overflow-x-auto custom-scrollbar rounded-lg border border-gray-200 shadow-sm">
                                    <table className="min-w-full divide-y divide-gray-200 bg-white">
                                        <thead className="bg-gray-50">
                                            <tr>
                                                {headers.map((header, index) => (
                                                    <th
                                                        key={index}
                                                        className="px-4 py-2 text-left text-xs font-medium text-gray-700 uppercase tracking-wider"
                                                    >
                                                        {header}
                                                    </th>
                                                ))}
                                            </tr>
                                        </thead>
                                        <tbody className="divide-y divide-gray-200">
                                            {matrixData.map((rowObject, rowIndex) => (
                                                <tr key={rowIndex} className="hover:bg-gray-50">
                                                    {headers.map((columnHeader, colIndex) => {
                                                        const cellValue = rowObject[columnHeader];
                                                        const originalColIndex = headers.indexOf(columnHeader); // Get original index for type inference

                                                        return (
                                                            <td key={`${rowIndex}-${colIndex}`} className="px-4 py-2 whitespace-nowrap">
                                                                {/* Conditional Input Rendering based on inferred type */}
                                                                {columnTypes[originalColIndex] === 'binary' ? (
                                                                    <button
                                                                        onClick={() => handleBinaryToggle(rowIndex, columnHeader)}
                                                                        className={`w-full px-2 py-1 rounded-md text-sm font-medium ${
                                                                            (String(cellValue).toLowerCase() === 'ya' || String(cellValue).toLowerCase() === 'true' || String(cellValue).toLowerCase() === '1')
                                                                                ? 'bg-green-500 text-white'
                                                                                : 'bg-red-500 text-white'
                                                                        } hover:opacity-80 transition duration-200`}
                                                                    >
                                                                        {(String(cellValue).toLowerCase() === 'ya' || String(cellValue).toLowerCase() === 'true' || String(cellValue).toLowerCase() === '1') ? 'Ya' : 'Tidak'}
                                                                    </button>
                                                                ) : columnTypes[originalColIndex] === 'number' ? (
                                                                    <input
                                                                        type="number"
                                                                        value={cellValue !== null && cellValue !== undefined ? cellValue : ''}
                                                                        onChange={(e) => handleCellChange(rowIndex, columnHeader, parseFloat(e.target.value))}
                                                                        className="w-full border border-gray-300 rounded-md px-2 py-1 text-sm text-gray-900 focus:ring-green-500 focus:border-green-500"
                                                                    />
                                                                ) : ( // Default to text
                                                                    <input
                                                                        type="text"
                                                                        value={cellValue !== null && cellValue !== undefined ? cellValue : ''}
                                                                        onChange={(e) => handleCellChange(rowIndex, columnHeader, e.target.value)}
                                                                        className="w-full border border-gray-300 rounded-md px-2 py-1 text-sm text-gray-900 focus:ring-green-500 focus:border-green-500"
                                                                    />
                                                                )}
                                                            </td>
                                                        );
                                                    })}
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            ) : (
                                <p className="text-center text-gray-500 mt-8">Unggah file Excel untuk melihat data.</p>
                            )}
                        </div>
                    </main>

                    {/* Footer Section - Minimalist */}
                    <footer className="p-4 text-center text-gray-600 text-sm mt-8">
                        <p>&copy; {new Date().getFullYear()} Spreadsheet Alam. Hak Cipta Dilindungi.</p>
                    </footer>

                    {/* AI Prompt Modal */}
                    {showAIPromptModal && (
                        <div className="fixed inset-0 bg-gray-900 bg-opacity-70 flex items-center justify-center p-4 z-50">
                            <div className="bg-white p-6 rounded-xl shadow-lg w-full max-w-md border border-gray-200">
                                <h2 className="text-2xl font-semibold text-gray-800 mb-4">Hasilkan Konten dengan AI</h2>
                                <textarea
                                    className="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:ring-green-500 focus:border-green-500 text-gray-800"
                                    rows="4"
                                    placeholder="Masukkan prompt Anda di sini (misalnya: 'Daftar 5 ide produk baru untuk startup teknologi')"
                                    value={aiPrompt}
                                    onChange={(e) => setAiPrompt(e.target.value)}
                                    disabled={isGeneratingAI}
                                ></textarea>
                                <div className="flex justify-end gap-3">
                                    <button
                                        onClick={() => setShowAIPromptModal(false)}
                                        className="px-5 py-2 bg-gray-300 text-gray-800 font-semibold rounded-full hover:bg-gray-400 transition duration-300"
                                        disabled={isGeneratingAI}
                                    >
                                        Batal
                                    </button>
                                    <button
                                        onClick={handleGenerateAIContent}
                                        className="px-5 py-2 bg-green-600 text-white font-semibold rounded-full shadow-md hover:bg-green-700 transition duration-300"
                                        disabled={isGeneratingAI}
                                    >
                                        {isGeneratingAI ? (
                                            <svg className="animate-spin h-5 w-5 text-white mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                            </svg>
                                        ) : (
                                            'Hasilkan'
                                        )}
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Voice Input Modal */}
                    {showVoiceInputModal && (
                        <div className="fixed inset-0 bg-gray-900 bg-opacity-70 flex items-center justify-center p-4 z-50">
                            <div className="bg-white p-6 rounded-xl shadow-lg w-full max-w-md border border-gray-200 text-center">
                                <h2 className="text-2xl font-semibold text-gray-800 mb-4">Input Suara</h2>
                                <p className="text-gray-700 text-lg mb-4">{voiceStatus}</p>
                                <p className="text-sm text-gray-600 mb-4">
                                    Untuk memperbarui data, ucapkan perintah seperti:
                                    <br/>
                                    "Untuk baris **'[Nilai Kolom Pertama]'** di kolom **'[Nama Kolom]'**, atur nilai menjadi **'[Nilai Baru]'**".
                                    <br/>
                                    Contoh: "Untuk baris 'Amphibia' di kolom 'jum', atur nilai menjadi 10"
                                </p>
                                {isGeneratingAI && ( // Reusing isGeneratingAI for voice processing
                                    <svg className="animate-spin h-8 w-8 text-green-700 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                )}
                                <div className="flex justify-center gap-3">
                                    <button
                                        onClick={() => {
                                            if (recognition) recognition.stop();
                                            setShowVoiceInputModal(false);
                                            setVoiceStatus('Siap');
                                            setIsGeneratingAI(false); // Ensure loading is reset
                                        }}
                                        className="px-5 py-2 bg-red-500 text-white font-semibold rounded-full shadow-md hover:bg-red-600 transition duration-300"
                                    >
                                        Tutup
                                    </button>
                                    {!isGeneratingAI && voiceStatus !== 'Mendengarkan...' && ( // Only show start if not already listening or processing
                                        <button
                                            onClick={startVoiceInput}
                                            className="px-5 py-2 bg-green-600 text-white font-semibold rounded-full shadow-md hover:bg-green-700 transition duration-300"
                                        >
                                            Mulai Mendengarkan
                                        </button>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Render the App component into the root div
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
