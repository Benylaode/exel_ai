<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spreadsheet Alam</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Merriweather for serif font -->
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Apply Merriweather as the serif font */
        body {
            font-family: 'Merriweather', serif;
        }
        /* Custom scrollbar, keeping for consistency */
        .overflow-x-auto::-webkit-scrollbar {
            height: 8px;
        }
        .overflow-x-auto::-webkit-scrollbar-track {
            background: #e0f2f1; /* Light green for track */
            border-radius: 10px;
        }
        .overflow-x-auto::-webkit-scrollbar-thumb {
            background: #4caf50; /* Green for thumb */
            border-radius: 10px;
        }
        .overflow-x-auto::-webkit-scrollbar-thumb:hover {
            background: #388e3c; /* Darker green on hover */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- React CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel Standalone for JSX transformation in browser (for development only) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- XLSX library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <script type="text/babel">
        const App = () => {
            const [workbook, setWorkbook] = React.useState(null);
            const [sheetNames, setSheetNames] = React.useState([]);
            const [activeSheetName, setActiveSheetName] = React.useState('');
            const [sheetData, setSheetData] = React.useState([]); // Raw array of arrays for XLSX operations
            const [matrixData, setMatrixData] = React.useState({}); // Dictionary-based data for display and manipulation
            const [headers, setHeaders] = React.useState([]); // Headers extracted from sheetData[0]
            const [message, setMessage] = React.useState('');
            const fileInputRef = React.useRef(null);

            // State for AI generation feature
            const [showAIPromptModal, setShowAIPromptModal] = React.useState(false);
            const [aiPrompt, setAiPrompt] = React.useState('');
            const [isGeneratingAI, setIsGeneratingAI] = React.useState(false);

            // State for voice input feature
            const [showVoiceInputModal, setShowVoiceInputModal] = React.useState(false);
            const [voiceStatus, setVoiceStatus] = React.useState('Siap');
            const [recognition, setRecognition] = React.useState(null);

            // State to store inferred column types
            const [columnTypes, setColumnTypes] = React.useState({}); // {colIndex: 'text' | 'number' | 'binary'}

            // New state to store the dynamically identified main identifier header name
            const [mainIdentifierHeader, setMainIdentifierHeader] = React.useState(null);


            // Helper to check if a value is predominantly text-like (contains letters, not just numbers/symbols)
            const isPredominantlyText = (value) => {
                if (typeof value !== 'string' && typeof value !== 'number') return false;
                const str = String(value).trim();
                if (str.length === 0) return false;
                // Check for presence of letters and not just numbers/symbols
                return /[a-zA-Z]/.test(str) && !/^\d+$/.test(str) && !/^[^\w\s]+$/.test(str);
            };

            // Function to dynamically find the best "name-like" column
            const findDynamicMainIdentifierColumn = (headers, dataRows) => {
                let bestColIndex = -1;
                let highestScore = -1;

                const sampleSize = Math.min(dataRows.length, 50); // Sample first 50 rows for analysis

                for (let colIndex = 0; colIndex < headers.length; colIndex++) {
                    let textLikeCount = 0;
                    let nmCount = 0; // Count of values containing 'n' or 'm'
                    let totalNonEmpty = 0;

                    for (let i = 0; i < sampleSize; i++) {
                        const row = dataRows[i];
                        const cellValue = row[colIndex];
                        if (cellValue !== null && cellValue !== undefined && String(cellValue).trim() !== '') {
                            totalNonEmpty++;
                            const strValue = String(cellValue).toLowerCase();
                            if (isPredominantlyText(cellValue)) {
                                textLikeCount++;
                            }
                            if (/[nm]/.test(strValue)) { // Check for 'n' or 'm'
                                nmCount++;
                            }
                        }
                    }

                    if (totalNonEmpty > 0) {
                        const textLikeRatio = textLikeCount / totalNonEmpty;
                        const nmRatio = nmCount / totalNonEmpty;

                        // Score based on being text-like and containing 'n' or 'm'
                        // Prioritize columns that are more text-like and have more 'n'/'m'
                        // Also, give a slight boost to earlier columns
                        let score = (textLikeRatio * 0.7) + (nmRatio * 0.3); // Weighted score
                        if (colIndex < 3) { // Boost for first few columns
                            score += 0.1 * (3 - colIndex);
                        }

                        if (score > highestScore) {
                            highestScore = score;
                            bestColIndex = colIndex;
                        }
                    }
                }

                console.log(`[Deteksi Kolom] Header yang terdeteksi sebagai 'nama/pengenal' utama: ${bestColIndex !== -1 ? headers[bestColIndex] : 'Tidak Ditemukan'}`);
                return bestColIndex;
            };


            // Utility function to convert raw sheet data (AoA) to dictionary matrix
            const convertSheetDataToMatrix = (data, detectedMainIdentifierHeader) => {
                if (!data || data.length < 1) return {};
                const currentHeaders = data[0];
                const dataRows = data.slice(1);
                const newMatrixData = {};

                const ignoredKeywords = ['total', 'jumlah', 'sum', 'rata-rata', 'average', 'max', 'min']; // Keywords to ignore in the main identifier column

                for (let i = 0; i < dataRows.length; i++) {
                    const row = dataRows[i];
                    const rowObject = {};

                    // Populate rowObject with all original headers and their values
                    currentHeaders.forEach((header, colIndex) => {
                        rowObject[header] = row[colIndex];
                    });

                    // Get value for the main identifier based on the detected header
                    const mainIdentifierValue = (detectedMainIdentifierHeader && rowObject[detectedMainIdentifierHeader] !== undefined) ? String(rowObject[detectedMainIdentifierHeader]).trim() : '';
                    
                    // Determine the primary key for matrixData
                    let primaryKey = mainIdentifierValue;
                    if (!primaryKey && currentHeaders.length > 0) {
                        primaryKey = String(rowObject[currentHeaders[0]] || `Baris ${i + 1}`).trim(); // Fallback to first column
                    } else if (!primaryKey) {
                        primaryKey = `Baris ${i + 1}`; // Generic fallback
                    }

                    // Check if this row should be ignored (e.g., a total row)
                    const isTotalRow = ignoredKeywords.some(keyword => 
                        primaryKey.toLowerCase().includes(keyword)
                    );

                    if (isTotalRow) {
                        console.log(`[Filter Baris] Mengabaikan baris: ${primaryKey} (terdeteksi sebagai baris total/kalkulasi)`);
                        continue; // Skip this row
                    }

                    // Handle potential duplicate primary keys
                    let uniquePrimaryKey = primaryKey;
                    let counter = 1;
                    while (newMatrixData.hasOwnProperty(uniquePrimaryKey)) {
                        uniquePrimaryKey = `${primaryKey} (${counter++})`;
                    }
                    newMatrixData[uniquePrimaryKey] = rowObject;
                }
                return newMatrixData;
            };

            // Utility function to convert dictionary matrix back to raw sheet data (AoA)
            const convertMatrixDataToSheetData = (matrix, originalHeaders) => {
                const newSheetData = [originalHeaders]; // Start with original headers

                for (const primaryKey of Object.keys(matrix)) {
                    const rowObject = matrix[primaryKey];
                    const rowArray = [];

                    originalHeaders.forEach((header) => {
                        rowArray.push(rowObject[header] !== undefined ? rowObject[header] : '');
                    });
                    newSheetData.push(rowArray);
                }
                return newSheetData;
            };

            // Effect to load data when workbook or active sheet changes
            React.useEffect(() => {
                if (workbook && activeSheetName) {
                    if (typeof XLSX !== 'undefined' && XLSX.utils) {
                        const ws = workbook.Sheets[activeSheetName];
                        const jsonSheetData = XLSX.utils.sheet_to_json(ws, { header: 1, raw: true });
                        setSheetData(jsonSheetData);

                        if (jsonSheetData.length > 0) {
                            setHeaders(jsonSheetData[0]); // Store original headers
                            
                            // Dynamically find the main identifier column
                            const detectedMainIdColIndex = findDynamicMainIdentifierColumn(jsonSheetData[0], jsonSheetData.slice(1));
                            const detectedMainIdHeader = detectedMainIdColIndex !== -1 ? jsonSheetData[0][detectedMainIdColIndex] : (jsonSheetData[0].length > 0 ? jsonSheetData[0][0] : null);
                            setMainIdentifierHeader(detectedMainIdHeader);

                            setMatrixData(convertSheetDataToMatrix(jsonSheetData, detectedMainIdHeader));
                            inferColumnTypes(jsonSheetData); // Infer types based on original data
                        } else {
                            setHeaders([]);
                            setMatrixData({});
                            setColumnTypes({});
                            setMainIdentifierHeader(null);
                        }
                    } else {
                        setMessage('Pustaka XLSX belum dimuat. Harap segarkan halaman.');
                    }
                }
            }, [workbook, activeSheetName]);

            // Initialize SpeechRecognition API
            React.useEffect(() => {
                if ('webkitSpeechRecognition' in window) {
                    const SpeechRecognition = window.webkitSpeechRecognition;
                    const recognitionInstance = new SpeechRecognition();
                    recognitionInstance.continuous = false; // Listen for a single utterance
                    recognitionInstance.interimResults = false; // Only return final results
                    recognitionInstance.lang = 'id-ID'; // Set language to Indonesian

                    recognitionInstance.onstart = () => {
                        setVoiceStatus('Mendengarkan...');
                    };

                    recognitionInstance.onresult = (event) => {
                        const transcript = event.results[0][0].transcript;
                        setVoiceStatus(`Terdengar: "${transcript}"`);
                        processVoiceCommand(transcript);
                    };

                    recognitionInstance.onerror = (event) => {
                        console.error('Speech recognition error:', event.error);
                        setVoiceStatus(`Kesalahan: ${event.error}. Coba lagi.`);
                        setIsGeneratingAI(false); // Reset loading state
                    };

                    recognitionInstance.onend = () => {
                        if (voiceStatus.startsWith('Mendengarkan')) { // If it ended without result
                            setVoiceStatus('Tidak ada suara terdeteksi.');
                            setIsGeneratingAI(false); // Reset loading state
                        }
                    };
                    setRecognition(recognitionInstance);
                } else {
                    setVoiceStatus('Browser Anda tidak mendukung Web Speech API.');
                }
            }, []); // Run once on component mount

            const inferColumnTypes = (data) => {
                if (!data || data.length < 1) {
                    setColumnTypes({});
                    return;
                }

                const newColumnTypes = {};
                const headerRow = data[0];
                const dataRows = data.slice(1);

                headerRow.forEach((header, colIndex) => {
                    let numericCount = 0;
                    let binaryCount = 0;
                    let totalCells = 0;

                    dataRows.forEach(row => {
                        const cellValue = row[colIndex];
                        if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                            totalCells++;
                            const numericValue = parseFloat(cellValue);
                            if (!isNaN(numericValue)) {
                                numericCount++;
                            }
                            const lowerCaseValue = String(cellValue).toLowerCase();
                            if (['ya', 'tidak', 'true', 'false', '1', '0'].includes(lowerCaseValue)) {
                                binaryCount++;
                            }
                        }
                    });

                    if (totalCells > 0) {
                        if (numericCount / totalCells > 0.8) { // If more than 80% are numbers
                            newColumnTypes[colIndex] = 'number';
                        } else if (binaryCount / totalCells > 0.8) { // If more than 80% are binary
                            newColumnTypes[colIndex] = 'binary';
                        } else {
                            newColumnTypes[colIndex] = 'text';
                        }
                    } else {
                        newColumnTypes[colIndex] = 'text'; // Default to text if no data
                    }
                });
                setColumnTypes(newColumnTypes);
            };

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (!file) {
                    setMessage('Tidak ada file yang dipilih.');
                    return;
                }

                if (typeof XLSX === 'undefined' || !XLSX.read) {
                    setMessage('Pustaka XLSX belum dimuat. Harap segarkan halaman atau coba lagi.');
                    return;
                }

                setMessage('Mengunggah dan memproses file...');
                const reader = new FileReader();

                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const wb = XLSX.read(data, { type: 'array' });
                        setWorkbook(wb);
                        setSheetNames(wb.SheetNames);
                        if (wb.SheetNames.length > 0) {
                            setActiveSheetName(wb.SheetNames[0]);
                            setMessage(`File "${file.name}" berhasil diunggah. Memuat sheet pertama.`);
                        } else {
                            setMessage('File Excel tidak memiliki sheet.');
                            setSheetData([]);
                            setMatrixData({});
                            setHeaders([]);
                            setColumnTypes({});
                            setMainIdentifierHeader(null);
                        }
                    } catch (error) {
                        console.error('Error reading Excel file:', error);
                        setMessage('Gagal membaca file Excel. Pastikan formatnya benar.');
                        setWorkbook(null);
                        setSheetNames([]);
                        setActiveSheetName('');
                        setSheetData([]);
                        setMatrixData({});
                        setHeaders([]);
                        setColumnTypes({});
                        setMainIdentifierHeader(null);
                    }
                };

                reader.onerror = () => {
                    setMessage('Gagal membaca file.');
                    setWorkbook(null);
                    setSheetNames([]);
                    setActiveSheetName('');
                    setSheetData([]);
                    setMatrixData({});
                    setHeaders([]);
                    setColumnTypes({});
                    setMainIdentifierHeader(null);
                };

                reader.readAsArrayBuffer(file);
            };

            const handleSheetChange = (sheetName) => {
                setActiveSheetName(sheetName);
                setMessage(`Beralih ke sheet: ${sheetName}`);
            };

            // Update cell in matrixData and then sync back to sheetData and workbook
            const updateCell = (primaryKey, columnHeader, value) => {
                const newMatrixData = { ...matrixData };
                if (!newMatrixData[primaryKey]) {
                    newMatrixData[primaryKey] = {};
                }
                newMatrixData[primaryKey][columnHeader] = value; // Update the specific attribute
                setMatrixData(newMatrixData);

                // Sync back to sheetData and workbook
                if (workbook && activeSheetName && typeof XLSX !== 'undefined' && XLSX.utils) {
                    const newSheetData = convertMatrixDataToSheetData(newMatrixData, headers);
                    setSheetData(newSheetData); // Update raw sheetData state
                    const ws = XLSX.utils.aoa_to_sheet(newSheetData);
                    workbook.Sheets[activeSheetName] = ws;
                    inferColumnTypes(newSheetData); // Re-infer types after update
                }
            };

            const handleCellChange = (primaryKey, columnHeader, value) => {
                updateCell(primaryKey, columnHeader, value);
            };

            const handleBinaryToggle = (primaryKey, columnHeader) => {
                const currentValue = String(matrixData[primaryKey][columnHeader]).toLowerCase();
                const newValue = (currentValue === 'ya' || currentValue === 'true' || currentValue === '1') ? 'Tidak' : 'Ya';
                updateCell(primaryKey, columnHeader, newValue);
            };

            const handleAddRow = (content = null) => {
                const newMatrixData = { ...matrixData };
                // Generate a unique primary key for the new row
                let newPrimaryKey = content || `Baris Baru ${Object.keys(newMatrixData).length + 1}`;
                let counter = 1;
                while (newMatrixData.hasOwnProperty(newPrimaryKey)) {
                    newPrimaryKey = `${content || `Baris Baru ${Object.keys(newMatrixData).length + 1}`} (${counter++})`;
                }

                const newRowObject = {};
                // Initialize all headers with empty strings
                headers.forEach(header => {
                    newRowObject[header] = '';
                });

                // If content is provided, try to parse it and put it in the main identifier column
                if (content && mainIdentifierHeader) {
                    newRowObject[mainIdentifierHeader] = content;
                } else if (content && headers.length > 0) {
                    newRowObject[headers[0]] = content; // Fallback to first column if mainIdentifierHeader is not set
                } else if (content) {
                    newRowObject['Kolom 1'] = content; // Fallback if no headers at all
                }

                newMatrixData[newPrimaryKey] = newRowObject;
                setMatrixData(newMatrixData);

                // Sync back to sheetData and workbook
                if (workbook && activeSheetName && typeof XLSX !== 'undefined' && XLSX.utils) {
                    const newSheetData = convertMatrixDataToSheetData(newMatrixData, headers);
                    setSheetData(newSheetData);
                    const ws = XLSX.utils.aoa_to_sheet(newSheetData);
                    workbook.Sheets[activeSheetName] = ws;
                    inferColumnTypes(newSheetData); // Re-infer types after adding row
                    setMessage(content ? 'Baris baru dengan konten AI ditambahkan.' : 'Baris baru ditambahkan.');
                }
            };

            const handleCalculateTotals = () => {
                if (!matrixData || Object.keys(matrixData).length === 0 || headers.length === 0) {
                    setMessage('Tidak ada data untuk dihitung total.');
                    return;
                }

                const totals = {};
                headers.forEach((header) => { // Iterate over all headers
                    // Skip the main identifier column for summation
                    if (header === mainIdentifierHeader) {
                        totals[header] = 'Total'; // Set the main identifier column of total row to 'Total'
                        return;
                    }

                    let sum = 0;
                    let isNumericColumn = true;
                    for (const primaryKey in matrixData) {
                        const cellValue = matrixData[primaryKey][header];
                        const numericValue = parseFloat(cellValue);
                        if (!isNaN(numericValue) && cellValue !== '' && cellValue !== null && cellValue !== undefined) {
                            sum += numericValue;
                        } else if (cellValue !== '' && cellValue !== null && cellValue !== undefined) {
                            isNumericColumn = false;
                            break; // Not a purely numeric column
                        }
                    }
                    if (isNumericColumn) {
                        totals[header] = sum;
                    } else {
                        totals[header] = ''; // Non-numeric columns don't get a sum
                    }
                });

                const newMatrixData = { ...matrixData };
                // Check if a "Total" row already exists based on primary key
                let totalRowExists = false;
                if (newMatrixData.hasOwnProperty('Total')) {
                    newMatrixData['Total'] = { ...totals }; // Update existing total row
                    totalRowExists = true;
                }

                if (!totalRowExists) {
                    // If no existing total row, create a new one with 'Total' as its primary key
                    newMatrixData['Total'] = { ...totals };
                }

                setMatrixData(newMatrixData);

                // Sync back to sheetData and workbook
                if (workbook && activeSheetName && typeof XLSX !== 'undefined' && XLSX.utils) {
                    const newSheetData = convertMatrixDataToSheetData(newMatrixData, headers);
                    setSheetData(newSheetData);
                    const ws = XLSX.utils.aoa_to_sheet(newSheetData);
                    workbook.Sheets[activeSheetName] = ws;
                    inferColumnTypes(newSheetData); // Re-infer types after adding total row
                    setMessage('Total kolom dihitung dan ditambahkan.');
                }
            };

            const handleGenerateAIContent = async () => {
                if (!aiPrompt.trim()) {
                    setMessage('Mohon masukkan prompt untuk AI.');
                    return;
                }
                if (!workbook || !activeSheetName) {
                    setMessage('Harap unggah file Excel terlebih dahulu.');
                    return;
                }

                setIsGeneratingAI(true);
                setMessage('Menghasilkan konten AI...');

                try {
                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: aiPrompt }] });
                    const payload = { contents: chatHistory };
                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const text = result.candidates[0].content.parts[0].text;
                        handleAddRow(text); // Add AI generated content as a new row (primary key)
                        setMessage('Konten AI berhasil dihasilkan dan ditambahkan.');
                    } else {
                        setMessage('Gagal menghasilkan konten AI. Coba lagi.');
                        console.error('Unexpected AI response structure:', result);
                    }
                } catch (error) {
                    console.error('Error calling Gemini API:', error);
                    setMessage('Terjadi kesalahan saat menghubungi AI. Mohon coba lagi.');
                } finally {
                    setIsGeneratingAI(false);
                    setShowAIPromptModal(false);
                    setAiPrompt('');
                }
            };

            const startVoiceInput = () => {
                if (recognition) {
                    setVoiceStatus('Mendengarkan...');
                    setShowVoiceInputModal(true);
                    recognition.start();
                } else {
                    setVoiceStatus('Web Speech API tidak tersedia.');
                }
            };

            const processVoiceCommand = async (command) => {
                setVoiceStatus('Memproses perintah suara dengan AI...');
                setIsGeneratingAI(true); // Reuse loading state for AI processing

                const geminiPrompt = `Parse this command to identify the target column's HEADER NAME (case-insensitive), the unique identifier for the row (which is the value displayed as the card title in your spreadsheet, case-insensitive), and the new value to be set. Respond in JSON format.
                If the command is not clear, respond with an empty JSON object {}.
                
                Current spreadsheet HEADER NAMES: ${JSON.stringify(headers || [])}
                Current ROW IDENTIFIERS (these are the full card titles, example: "Amphibia", "Reptilia", "Spesies X (Famili A)"): ${JSON.stringify(Object.keys(matrixData) || [])}
                
                Examples:
                - "Untuk baris 'Amphibia' di kolom 'jum', atur nilai menjadi 10" -> { "column": "jum", "row_identifier_value": "Amphibia", "new_value": 10 }
                - "Untuk baris 'Reptilia' di kolom 'F', masukkan 0.75" -> { "column": "F", "row_identifier_value": "Reptilia", "new_value": 0.75 }
                - "Untuk baris 'Spesies X (Famili A)' di kolom 'status', ubah menjadi 'Dilindungi'" -> { "column": "status', "row_identifier_value": "Spesies X (Famili A)", "new_value": "Dilindungi" }
                
                Command to parse: "${command}"`;

                try {
                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: geminiPrompt }] });
                    const payload = {
                        contents: chatHistory,
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    "column": { "type": "STRING" },
                                    "row_identifier_value": { "type": "STRING" },
                                    "new_value": { "type": ["STRING", "NUMBER", "BOOLEAN"] }
                                },
                                required: ["column", "row_identifier_value", "new_value"]
                            }
                        }
                    };
                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        const parsedCommand = JSON.parse(jsonText);

                        const { column, row_identifier_value, new_value } = parsedCommand;

                        if (!column || !row_identifier_value || new_value === undefined) {
                            setMessage('Perintah suara tidak jelas atau tidak lengkap.');
                            setVoiceStatus('Perintah tidak dapat dipahami.');
                            return;
                        }

                        // Find the actual primary key (case-insensitive match)
                        const actualPrimaryKey = Object.keys(matrixData).find(key => String(key).toLowerCase() === String(row_identifier_value).toLowerCase());

                        if (!actualPrimaryKey) {
                            setMessage(`Baris dengan pengenal '${row_identifier_value}' tidak ditemukan.`);
                            setVoiceStatus(`Baris tidak ditemukan.`);
                            return;
                        }

                        // Find the actual column header (case-insensitive match)
                        const actualColumnHeader = headers.find(header => String(header).toLowerCase() === String(column).toLowerCase());

                        if (!actualColumnHeader) {
                            setMessage(`Kolom '${column}' tidak ditemukan.`);
                            setVoiceStatus(`Kolom '${column}' tidak ditemukan.`);
                            return;
                        }

                        updateCell(actualPrimaryKey, actualColumnHeader, new_value);
                        setMessage(`Berhasil memperbarui kolom '${actualColumnHeader}' di baris '${actualPrimaryKey}' menjadi '${new_value}'.`);
                        setVoiceStatus('Berhasil diperbarui!');

                    } else {
                        setMessage('Gagal memproses perintah suara dengan AI. Coba lagi.');
                        setVoiceStatus('Gagal memproses perintah.');
                        console.error('Unexpected AI response structure:', result);
                    }
                } catch (error) {
                    console.error('Error processing voice command with Gemini API:', error);
                    setMessage('Terjadi kesalahan saat memproses perintah suara. Mohon coba lagi.');
                    setVoiceStatus('Kesalahan pemrosesan.');
                } finally {
                    setIsGeneratingAI(false); // Reset loading state
                    // setShowVoiceInputModal(false); // Keep modal open to show status
                }
            };


            const handleDownload = () => {
                if (!workbook) {
                    setMessage('Tidak ada file Excel untuk diunduh.');
                    return;
                }

                if (typeof XLSX === 'undefined' || !XLSX.utils || !XLSX.writeFile) {
                    setMessage('Pustaka XLSX belum dimuat. Harap segarkan halaman atau coba lagi.');
                    return;
                }

                try {
                    const wb = XLSX.utils.book_new();
                    sheetNames.forEach(sheetName => {
                        let ws;
                        if (sheetName === activeSheetName) {
                            // Convert current matrixData back to AoA for the active sheet
                            ws = XLSX.utils.aoa_to_sheet(convertMatrixDataToSheetData(matrixData, headers));
                        } else {
                            // For other sheets, use the original workbook sheet
                            ws = workbook.Sheets[sheetName];
                        }
                        XLSX.utils.book_append_sheet(wb, ws, sheetName);
                    });

                    XLSX.writeFile(wb, 'modified_spreadsheet.xlsx');
                    setMessage('File Excel berhasil diunduh.');
                } catch (error) {
                    console.error('Error downloading Excel file:', error);
                    setMessage('Gagal mengunduh file Excel.');
                }
            };

            return (
                <div className="min-h-screen flex flex-col font-serif bg-gradient-to-br from-green-50 to-green-200">
                    {/* Header Section */}
                    <header className="bg-green-800 text-white p-4 shadow-md">
                        <div className="container mx-auto flex justify-between items-center">
                            <h1 className="text-2xl sm:text-3xl font-bold">ðŸŒ¿ Spreadsheet Alam</h1>
                        </div>
                    </header>

                    {/* Main Content */}
                    <main className="flex-grow flex flex-col items-center p-4">
                        <div className="bg-green-100 p-6 rounded-xl shadow-lg w-full max-w-6xl border border-green-300">
                            <h2 className="text-2xl font-bold text-center text-green-800 mb-6">Editor Spreadsheet Interaktif</h2>

                            <div className="mb-6 flex flex-col sm:flex-row items-center justify-center gap-4 flex-wrap">
                                <input
                                    type="file"
                                    accept=".xlsx, .xls"
                                    onChange={handleFileUpload}
                                    ref={fileInputRef}
                                    className="hidden"
                                />
                                <button
                                    onClick={() => fileInputRef.current.click()}
                                    className="px-6 py-3 bg-green-700 text-white font-semibold rounded-lg shadow-md hover:bg-green-800 focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-opacity-75 transition duration-300 ease-in-out"
                                >
                                    Unggah File Excel
                                </button>

                                {workbook && (
                                    <>
                                        <button
                                            onClick={() => handleAddRow()}
                                            className="px-6 py-3 bg-emerald-600 text-white font-semibold rounded-lg shadow-md hover:bg-emerald-700 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-opacity-75 transition duration-300 ease-in-out"
                                        >
                                            Tambah Baris
                                        </button>
                                        <button
                                            onClick={handleCalculateTotals}
                                            className="px-6 py-3 bg-lime-600 text-white font-semibold rounded-lg shadow-md hover:bg-lime-700 focus:outline-none focus:ring-2 focus:ring-lime-500 focus:ring-opacity-75 transition duration-300 ease-in-out"
                                        >
                                            Hitung Semua Total
                                        </button>
                                        <button
                                            onClick={() => setShowAIPromptModal(true)}
                                            className="px-6 py-3 bg-amber-600 text-white font-semibold rounded-lg shadow-md hover:bg-amber-700 focus:outline-none focus:ring-2 focus:ring-amber-500 focus:ring-opacity-75 transition duration-300 ease-in-out"
                                        >
                                            Hasilkan Konten AI
                                        </button>
                                        <button
                                            onClick={startVoiceInput}
                                            className="px-6 py-3 bg-sky-600 text-white font-semibold rounded-lg shadow-md hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-opacity-75 transition duration-300 ease-in-out"
                                        >
                                            Input Suara AI
                                        </button>
                                        <button
                                            onClick={handleDownload}
                                            className="px-6 py-3 bg-teal-600 text-white font-semibold rounded-lg shadow-md hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-opacity-75 transition duration-300 ease-in-out"
                                        >
                                            Unduh Excel
                                        </button>
                                    </>
                                )}
                            </div>

                            {message && (
                                <p className="text-center text-green-700 mb-4">{message}</p>
                            )}

                            {sheetNames.length > 1 && (
                                <div className="mb-4 flex flex-wrap justify-center gap-2">
                                    {sheetNames.map((name) => (
                                        <button
                                            key={name}
                                            onClick={() => handleSheetChange(name)}
                                            className={`px-4 py-2 rounded-lg text-sm font-medium transition duration-300 ease-in-out ${
                                                activeSheetName === name
                                                    ? 'bg-green-600 text-white shadow-md'
                                                    : 'bg-green-200 text-green-800 hover:bg-green-300'
                                            }`}
                                        >
                                            {name}
                                        </button>
                                    ))}
                                </div>
                            )}

                            {Object.keys(matrixData).length > 0 && headers.length > 0 && (
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                    {Object.keys(matrixData).map((primaryKey) => (
                                        <div key={primaryKey} className="bg-white p-4 rounded-lg shadow-md border border-green-200 flex flex-col">
                                            {/* Display the value of the main identifier column as the card title */}
                                            <h3 className="text-lg font-bold text-green-800 mb-2">
                                                {mainIdentifierHeader && matrixData[primaryKey][mainIdentifierHeader] ? matrixData[primaryKey][mainIdentifierHeader] : primaryKey}
                                                {primaryKey === 'Total' && <span className="text-gray-500 normal-case ml-2">(Total)</span>}
                                            </h3>
                                            <div className="flex flex-col gap-2">
                                                {/* Display other attributes, excluding the main identifier column */}
                                                {headers.filter(header => header !== mainIdentifierHeader).map((columnHeader) => {
                                                    const cellValue = matrixData[primaryKey][columnHeader];
                                                    const originalColIndex = headers.indexOf(columnHeader);

                                                    return (
                                                        <div key={columnHeader} className="flex items-center justify-between text-sm text-gray-700">
                                                            <span className="font-medium pr-2">{columnHeader}:</span>
                                                            <div className="flex-grow">
                                                                {/* Conditional Input Rendering based on inferred type */}
                                                                {columnTypes[originalColIndex] === 'binary' ? (
                                                                    <button
                                                                        onClick={() => handleBinaryToggle(primaryKey, columnHeader)}
                                                                        className={`w-full px-1 py-0.5 rounded-md text-sm font-medium ${
                                                                            (String(cellValue).toLowerCase() === 'ya' || String(cellValue).toLowerCase() === 'true' || String(cellValue).toLowerCase() === '1')
                                                                                ? 'bg-green-500 text-white'
                                                                                : 'bg-red-500 text-white'
                                                                        } hover:opacity-80 transition duration-200`}
                                                                    >
                                                                        {(String(cellValue).toLowerCase() === 'ya' || String(cellValue).toLowerCase() === 'true' || String(cellValue).toLowerCase() === '1') ? 'Ya' : 'Tidak'}
                                                                    </button>
                                                                ) : columnTypes[originalColIndex] === 'number' ? (
                                                                    <input
                                                                        type="number"
                                                                        value={cellValue !== null && cellValue !== undefined ? cellValue : ''}
                                                                        onChange={(e) => handleCellChange(primaryKey, columnHeader, parseFloat(e.target.value))}
                                                                        className="w-full border border-green-300 rounded-md px-1 py-0.5 text-sm text-gray-900 focus:ring-green-500 focus:border-green-500"
                                                                    />
                                                                ) : ( // Default to text
                                                                    <input
                                                                        type="text"
                                                                        value={cellValue !== null && cellValue !== undefined ? cellValue : ''}
                                                                        onChange={(e) => handleCellChange(primaryKey, columnHeader, e.target.value)}
                                                                        className="w-full border border-green-300 rounded-md px-1 py-0.5 text-sm text-gray-900 focus:ring-green-500 focus:border-green-500"
                                                                    />
                                                                )}
                                                            </div>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    </main>

                    {/* Footer Section */}
                    <footer className="bg-green-800 text-white p-4 mt-8">
                        <div className="container mx-auto text-center text-sm">
                            <p>&copy; {new Date().getFullYear()} Spreadsheet Alam. Hak Cipta Dilindungi.</p>
                            <p>Dibuat dengan sentuhan alam dan AI.</p>
                        </div>
                    </footer>

                    {/* AI Prompt Modal */}
                    {showAIPromptModal && (
                        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50">
                            <div className="bg-green-100 p-6 rounded-xl shadow-lg w-full max-w-md border border-green-300">
                                <h2 className="text-2xl font-bold text-green-800 mb-4">Hasilkan Konten dengan AI</h2>
                                <textarea
                                    className="w-full p-3 border border-green-300 rounded-lg mb-4 focus:ring-green-500 focus:border-green-500 text-gray-800"
                                    rows="4"
                                    placeholder="Masukkan prompt Anda di sini (misalnya: 'Daftar 5 ide produk baru untuk startup teknologi')"
                                    value={aiPrompt}
                                    onChange={(e) => setAiPrompt(e.target.value)}
                                    disabled={isGeneratingAI}
                                ></textarea>
                                <div className="flex justify-end gap-3">
                                    <button
                                        onClick={() => setShowAIPromptModal(false)}
                                        className="px-5 py-2 bg-gray-300 text-gray-800 font-semibold rounded-lg hover:bg-gray-400 transition duration-300"
                                        disabled={isGeneratingAI}
                                    >
                                        Batal
                                    </button>
                                    <button
                                        onClick={handleGenerateAIContent}
                                        className="px-5 py-2 bg-green-700 text-white font-semibold rounded-lg shadow-md hover:bg-green-800 transition duration-300"
                                        disabled={isGeneratingAI}
                                    >
                                        {isGeneratingAI ? (
                                            <svg className="animate-spin h-5 w-5 text-white mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                            </svg>
                                        ) : (
                                            'Hasilkan'
                                        )}
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Voice Input Modal */}
                    {showVoiceInputModal && (
                        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50">
                            <div className="bg-green-100 p-6 rounded-xl shadow-lg w-full max-w-md border border-green-300 text-center">
                                <h2 className="text-2xl font-bold text-green-800 mb-4">Input Suara</h2>
                                <p className="text-green-700 text-lg mb-4">{voiceStatus}</p>
                                <p className="text-sm text-gray-600 mb-4">
                                    Untuk memperbarui data, ucapkan perintah seperti:
                                    <br/>
                                    "Untuk baris **'[Judul Kartu]'** di kolom **'[Nama Kolom]'**, atur nilai menjadi **'[Nilai Baru]'**".
                                    <br/>
                                    Contoh: "Untuk baris 'Amphibia' di kolom 'jum', atur nilai menjadi 10"
                                </p>
                                {isGeneratingAI && ( // Reusing isGeneratingAI for voice processing
                                    <svg className="animate-spin h-8 w-8 text-green-700 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                )}
                                <div className="flex justify-center gap-3">
                                    <button
                                        onClick={() => {
                                            if (recognition) recognition.stop();
                                            setShowVoiceInputModal(false);
                                            setVoiceStatus('Siap');
                                            setIsGeneratingAI(false); // Ensure loading is reset
                                        }}
                                        className="px-5 py-2 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 transition duration-300"
                                    >
                                        Tutup
                                    </button>
                                    {!isGeneratingAI && voiceStatus !== 'Mendengarkan...' && ( // Only show start if not already listening or processing
                                        <button
                                            onClick={startVoiceInput}
                                            className="px-5 py-2 bg-green-700 text-white font-semibold rounded-lg shadow-md hover:bg-green-800 transition duration-300"
                                        >
                                            Mulai Mendengarkan
                                        </button>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Render the App component into the root div
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
